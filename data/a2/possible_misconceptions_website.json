// https://progmiscon.org/misconceptions/Java/
[
    {
        "url": "https://progmiscon.org/misconceptions/Java/AssignCompares",
        "title": "AssignCompares",
        "description": "= compares two values, = compares two values"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/AddMemberAtRuntime",
        "title": "AddMemberAtRuntime",
        "description": "Set of class members can change at runtime, Set of class members can change at runtime"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/AssignmentNotExpression",
        "title": "AssignmentNotExpression",
        "description": "An assignment a=b is not an expression, An assignment a=b is not an expression"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ArraysGrow",
        "title": "ArraysGrow",
        "description": "Arrays can grow dynamically, Arrays can grow dynamically"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ArithmeticPlusPrecedes",
        "title": "ArithmeticPlusPrecedes",
        "description": "Addition has higher precedence than string concatenation, Addition has higher precedence than string concatenation"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/CallNotStaticallyChecked",
        "title": "CallNotStaticallyChecked",
        "description": "A method invocation on a reference of a type that does not have that method won't compile, A method invocation on a reference of a type that does not have th..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ArrayHasLengthMethod",
        "title": "ArrayHasLengthMethod",
        "description": "To get the length of an array, one needs to call its length method, To get the length of an array, one needs to call its length method"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ArrayListIsArray",
        "title": "ArrayListIsArray",
        "description": "ArrayLists are arrays, ArrayLists are arrays"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/AssignmentCopiesObject",
        "title": "AssignmentCopiesObject",
        "description": "Assignment copies the object, Assignment copies the object"
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ComparisonWithBooleanLiteral",
        "title": "ComparisonWithBooleanLiteral",
        "description": "To test whether an expression is true or false, one must compare it to true or to false."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/BaseCaseNotNeeded",
        "title": "BaseCaseNotNeeded",
        "description": "Any terminating recursive computation needs some kind of base case. The following directly-recursive method wihout base case represents a recursive computation ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/NoAtomicExpression",
        "title": "NoAtomicExpression",
        "description": "An expression is a piece of code that evaluates to a value. Anything that evaluates to a value is an expression. A single variable name also evaluates to a ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ReturnUnwindsMultipleFrames",
        "title": "ReturnUnwindsMultipleFrames",
        "description": "A return statement always returns to the call site that called the current method. It always unwinds only one call stack frame. It only finishes the current ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/VariablesHoldExpressions",
        "title": "VariablesHoldExpressions",
        "description": "Variables hold values. In Java, an expression is not a value. Thus, variables cannot store expressions. However, an expression can be evaluated, producing a ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ParenthesesOnlyIfArgument",
        "title": "ParenthesesOnlyIfArgument",
        "description": "In Java parentheses are required to distinguish method calls ( o.m() ) from field accesses ( o.f ). When calling any method, even a method without ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ConstructorAllocates",
        "title": "ConstructorAllocates",
        "description": "If students use new C() inside a constructor C() , you may discuss how this would recursively invoke the constructor. Have them try this out, and see how it ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/MapToBooleanWithIf",
        "title": "MapToBooleanWithIf",
        "description": "The condition to be used in an if statement has to be an expression of type boolean . Thus, that expression already will evaluate to a boolean value."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ObjectsMustBeNamed",
        "title": "ObjectsMustBeNamed",
        "description": "Writing new Object() on its own is perfectly fine. It will allocate a new object and invoke its constructor. If the expression stands on its own (i.e., ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/TargetTyping",
        "title": "TargetTyping",
        "description": "The type can be determined by statically analyzing the expression bottom up: the type of the subexpressions and the signatures of the operators or methods used."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/RecursiveActivationsShareFrame",
        "title": "RecursiveActivationsShareFrame",
        "description": "In the C programming language, local variables can be declared static, which means that while their scope is the function in which they are declared, their ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/RecursiveMethodNeedsIfElse",
        "title": "RecursiveMethodNeedsIfElse",
        "description": "The recursive call site represents a dynamic dispatch, either to Nil.contains() (base case) or to Cons.contains() (recursive case)."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ReturnCall",
        "title": "ReturnCall",
        "description": "Here is what's right. The return statement is a special kind of statement, starting with the word return . That word is either followed by an expression that ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/CannotChainMemberToConstructor",
        "title": "CannotChainMemberToConstruc...",
        "description": "The expression new C() evaluates to an object reference of type C , and it is perfectly legal to invoke a method on that object reference."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/LocalVariablesAutoInitialized",
        "title": "LocalVariablesAutoInitialized",
        "description": "Here is what's right. In Java, all local variables have to be explicitly initialized before they can be used. class C { void ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/InlineVariableInExpressionTree",
        "title": "InlineVariableInExpressionTree",
        "description": "The expression tree of an expression involving a variable inlines the variable's definition."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/RightToLeftChaining",
        "title": "RightToLeftChaining",
        "description": "The correct way to execute chained method calls, is from left to right (from the bottom to the top in the expression tree). For the example expression, first a ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/NullIsObject",
        "title": "NullIsObject",
        "description": "null is a value that does not point to anything. All other reference values point to some heap object, but null means that it does not point anywhere. Origin."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/LoopBodyScopeImpliesLoopLifetime",
        "title": "LoopBodyScopeImpliesLoopLifet...",
        "description": "The lifetime of a variable declared in a loop corresponds to one iteration only, not to all iterations of the loop. for (int element : array) ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ElseAlwaysExecutes",
        "title": "ElseAlwaysExecutes",
        "description": "The else branch of an if-else statement only executes if the condition evaluates to false. Correction. Here is what's right. In an if-else-statement, ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ControlledLocalAccess",
        "title": "ControlledLocalAccess",
        "description": "One can control access to local variables using access modifiers."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/CharNotNumeric",
        "title": "CharNotNumeric",
        "description": "Value. How can you build on this misconception? The char type in Java provides a leaky abstraction. It claims to represent an individual character. At the same ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ConstructorWithoutNew",
        "title": "ConstructorWithoutNew",
        "description": "Correction. Here is what's right. One cannot call the constructor without using the new keyword. The new in front stands for the object allocation, the ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/CallRequiresVariable",
        "title": "CallRequiresVariable",
        "description": "One can invoke a method on an object without the reference to that object being stored in a variable. All that is needed is that the expression in front of ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/NestedPackages",
        "title": "NestedPackages",
        "description": "Here is what's right. In Java, packages cannot cannot be nested. All packages are top-level packages. Package java.awt and package java.awt.event ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/PreIncrementBeforeLoop",
        "title": "PreIncrementBeforeLoop",
        "description": "Correction. Here is what's right. ... This is wrong! ... The ++ happens before or after the value of i is read. In both cases above, the value of i is read, but is ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/LargeIntegerLong",
        "title": "LargeIntegerLong",
        "description": "The following tree shows the reason for this compiler error: (long)12345678901234 is an expression consisting of a cast operator (long) and its operand, the ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/OnlyInnermostArrayElements",
        "title": "OnlyInnermostArrayElements",
        "description": "Only the elements of the innermost array of a multi-dimensional array are accessible."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/FinalReferenceImpliesImmutability",
        "title": "FinalReferenceImpliesImmutability",
        "description": "An object referred to by a final variable is an immutable object."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/CatchProvidesOptions",
        "title": "CatchProvidesOptions",
        "description": "If p==null , then x=p.x throws a NullPointerException , which is caught by the catch block. Now the entire catch block executes (not only the statement ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/VoidMethodNotRecursive",
        "title": "VoidMethodNotRecursive",
        "description": "This misconception might originate from students learning pure functional programming before learning an imperative language. In that case they encountered ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/NoLongLiterals",
        "title": "NoLongLiterals",
        "description": "Java does have long literals. The suffix l or L denotes a long literal. Some examples of Java long literals: 1L. 1234l. Language. Java."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ReferringToRecursiveStructureMakesRecursive",
        "title": "ReferringToRecursiveStructureM...",
        "description": "A class referring to a recursive data structure is (indirectly) part of that recursion as well."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ReferenceIntoStack",
        "title": "ReferenceIntoStack",
        "description": "Here is what's right. A reference in Java refers to objects on the heap. In Java one cannot refer to data on the stack. Language."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/SuperAlwaysHasParentheses",
        "title": "SuperAlwaysHasParentheses",
        "description": "To call a method on a superclass, it is wrong to write parentheses after the keyword super. Language. Java. jls21. 15.12 Method Invocation Expressions ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ConcreteClassMustOverride",
        "title": "ConcreteClassMustOverride",
        "description": "A concrete class needs to implement all abstract methods and override all concrete methods declared in its abstract superclasses."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/ExceptionRoot",
        "title": "ExceptionRoot",
        "description": "Here is what's right. The the root of the exception class hierarchy is class java.lang.Throwable . This class has two subclasses: java.lang ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/AbstractClassNoImplementation",
        "title": "AbstractClassNoImplementation",
        "description": "An abstract class cannot contain implemented methods. Correct. An abstract class can also contain implemented methods ..."
    },
    {
        "url": "https://progmiscon.org/misconceptions/Java/NullPointerExceptionCompileTime",
        "title": "NullPointerExceptionCompileTime",
        "description": "NullPointerExceptions are detected at compile time. Correct. NullPointerExceptions are detected at runtime. Language. Java."
    }
]
